/*******************************************************************************
* TORC - Copyright 2010 University of Southern California. All Rights Reserved.
*
* FILE : scanner.hpp
*
* DATE : 08-July-2010
*
* DESCRIPTION : Declaration of torc::generic::Scanner class 
*
* REVISION HISTORY:
*
* SI        REVISION        AUTHOR               CHANGES          PRs
*[0]    Initial Version    Niladri
*
*******************************************************************************/

#ifndef TORC__EDIF_SCANNER_HPP
#define TORC__EDIF_SCANNER_HPP

// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared. We can factor both as follows.

#ifndef YY_DECL

#define    YY_DECL                        \
    torc::generic::Parser::token_type                \
    torc::generic::Scanner::lex(                \
    torc::generic::Parser::semantic_type* yylval,        \
    torc::generic::Parser::location_type* yylloc        \
    )
#endif

#ifndef __FLEX_LEXER_H
#define yyFlexLexer EdifFlexLexer
#include "torc/generic/parser/FlexLexer.h"
#undef EdifFlexLexer
#endif

#include "torc/generic/parser/Parser.h"

namespace torc {
namespace generic {

/** Scanner is a derived class to add some extra function to the scanner
 * class. Flex itself creates a class named FlexLexer, which is renamed using
 * macros to EdifFlexLexer. However we change the context of the generated
 * yylex() function to be contained within the Scanner class. This is required
 * because the yylex() defined in EdifFlexLexer has no parameters. */
class Scanner : public EdifFlexLexer
{
  public:
    /** Create a new scanner object. The streams arg_yyin and arg_yyout default
     * to cin and cout, but that assignment is only made when initializing in
     * yylex(). */
    Scanner(std::istream* arg_yyin = 0,
        std::ostream* arg_yyout = 0);

    /** Required for virtual functions */
    virtual ~Scanner();

    /** This is the main lexing function. It is generated by flex according to
     * the macro declaration YY_DECL above. The generated bison parser then
     * calls this virtual function to fetch new tokens. */
    virtual Parser::token_type lex(
    Parser::semantic_type* yylval,
    Parser::location_type* yylloc
    );

    /** Enable debug output (via arg_yyout) if compiled into the scanner. */
    void set_debug(bool b);

    inline bool
    getIsIdContext() const throw();

    inline void
    setIsIdContext( bool inIsIdContext ) throw();

    void
    skipThisRule( char *yytext );

	inline bool
	getAppendToBuffer() throw();

	void
	setAppendToBuffer( bool inAppendToBuffer ) throw();

	void
	resetBuffer() throw();

	void
	addToBuffer( const char *str ) throw();

	inline std::string
	getBuffer() throw(); 

	inline bool
	getAppendToUserDataBuffer() throw();

	void
	setAppendToUserDataBuffer( bool inAppendToBuffer ) throw();

	void
	addToUserDataBuffer( const char *str ) throw();

	void
	resetUserDataBuffer() throw();

	inline std::string
	getUserDataBuffer() throw(); 

  private:
    bool mIsIdContext;
	bool mAppendToBuffer;
	bool mAppendToUserDataBuffer;
	std::string mBuffer;
	std::string mUserDataBuffer;
    bool mIsIdAlreadyAdded;
};

inline bool
Scanner::getIsIdContext() const throw() {
    return mIsIdContext;
}

inline void
Scanner::setIsIdContext( bool inIsIdContext ) throw() {
    mIsIdContext = inIsIdContext;
}
 
inline bool
Scanner::getAppendToBuffer() throw() {
	return mAppendToBuffer;
}

inline std::string
Scanner::getBuffer() throw() {
	return mBuffer;
}

inline bool
Scanner::getAppendToUserDataBuffer() throw() {
	return mAppendToUserDataBuffer;
}

inline std::string
Scanner::getUserDataBuffer() throw() {
	return mUserDataBuffer;
}

} // namespace generic
} // namespace torc

#endif // TORC__EDIF_SCANNER_HPP
